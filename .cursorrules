# Cursor Rules - Language Learning Flashcard App

@README.md

## Git Commit Rules âœ… **NEW**
- **CONCISE commit messages** - Maximum 200 characters total
- **FORMAT**: `type: brief description (max 150 chars)`
- **TYPES**: feat, fix, refactor, docs, style, test, chore
- **FOCUS**: What changed, not why (details in code/docs)
- **EXAMPLES**:
  - `feat: add TTS caching with GCS integration`
  - `fix: resolve blueprint URL routing issues`
  - `refactor: simplify level progression logic`

## Project Overview
This is a Flask-based Language Learning Flashcard App with the following key characteristics:
- **Core Purpose**: ANKI-style flashcards with European Portuguese text-to-speech
- **Data Source**: Google Sheets integration for vocabulary management
- **Architecture**: Modular Flask app with Blueprint-based routing âœ… **COMPLETED**
- **Features**: Statistics tracking, PWA support, OAuth authentication
- **Deployment**: Railway/Heroku compatible with Poetry + requirements.txt
- **Code Quality**: Pre-commit hooks with ruff linting/formatting âœ… **COMPLETED**

## Project Structure Analysis

### Core Application Files
```
app.py                          # Entry point - creates Flask app and handles dev/prod modes
src/                           # Main application module
â”œâ”€â”€ __init__.py               # Flask app factory with blueprint registration
â”œâ”€â”€ routes/                   # âœ… NEW: Blueprint-based route organization
â”‚   â”œâ”€â”€ __init__.py          # Blueprint registration (23 lines)
â”‚   â”œâ”€â”€ auth.py              # Authentication routes (155 lines)
â”‚   â”œâ”€â”€ flashcard.py         # Core learning functionality (306 lines)
â”‚   â”œâ”€â”€ settings.py          # User settings & spreadsheet config (119 lines)
â”‚   â”œâ”€â”€ api.py               # TTS and API endpoints (121 lines)
â”‚   â”œâ”€â”€ admin.py             # Database administration (237 lines)
â”‚   â””â”€â”€ test.py              # Testing & debugging (81 lines)
â”œâ”€â”€ models.py                # Pydantic data models
â”œâ”€â”€ config.py                # Dynaconf configuration management
â”œâ”€â”€ gsheet.py                # Google Sheets API integration
â”œâ”€â”€ auth.py                  # Google OAuth authentication
â”œâ”€â”€ database.py              # SQLAlchemy database operations
â”œâ”€â”€ tts_service.py           # Text-to-Speech service (14KB)
â”œâ”€â”€ user_manager.py          # User management utilities
â””â”€â”€ utils.py                 # Helper utilities
```

### Frontend & Templates
```
templates/                    # Jinja2 HTML templates
â”œâ”€â”€ base.html                # Base template
â”œâ”€â”€ index.html              # Homepage
â”œâ”€â”€ card.html               # Flashcard interface
â”œâ”€â”€ feedback.html           # Answer feedback
â”œâ”€â”€ results.html            # Session results
â”œâ”€â”€ settings.html           # User settings
â”œâ”€â”€ login.html              # Authentication
â”œâ”€â”€ setup.html              # Initial setup
â”œâ”€â”€ test_tts.html           # TTS testing
â”œâ”€â”€ offline.html            # PWA offline page
â””â”€â”€ error.html              # Error handling

static/                      # Frontend assets
â”œâ”€â”€ css/                    # Stylesheets
â”œâ”€â”€ js/                     # JavaScript
â”œâ”€â”€ icons/                  # PWA icons
â”œâ”€â”€ manifest.json           # PWA manifest
â””â”€â”€ sw.js                   # Service worker
```

### Configuration & Dependencies
```
pyproject.toml              # Poetry configuration with dependencies
requirements.txt            # Railway deployment requirements
settings.toml              # Main configuration (non-sensitive)
.secrets.toml              # Sensitive configuration (not in git)
.secrets.toml.example      # Template for secrets
.pre-commit-config.yaml    # âœ… NEW: Code quality automation
```

### Data & Authentication
```
data/
â”œâ”€â”€ app.db                 # SQLite database
â””â”€â”€ .gitkeep

google-cloud-service-account.json  # GCloud TTS credentials
client_secret.json                 # OAuth credentials
```

### Deployment & Documentation
```
Procfile                   # Railway/Heroku process file
railway.toml              # Railway configuration
runtime.txt               # Python version specification
TTS_SETUP.md              # Text-to-speech setup guide
src/routes_original_backup.py  # Backup of original monolithic routes
```

## Architecture Analysis

### âœ… COMPLETED IMPROVEMENTS
1. **âœ… Monolithic routes.py SPLIT** - Successfully broken into 6 focused blueprints
2. **âœ… Blueprint Architecture** - Clean separation of concerns by feature
3. **âœ… Type Safety** - Added comprehensive type hints throughout
4. **âœ… Error Handling** - Improved exception handling in all modules
5. **âœ… Data Persistence Strategy** - Deliberate dual-store architecture implemented
6. **âœ… Pre-commit Code Quality** - Automated linting, formatting, and security checks
7. **âœ… TTS Caching System** - GCS-based caching with spreadsheet-specific organization
8. **âœ… Comprehensive Logging** - Structured logging across all modules for debugging
9. **âœ… Level Progression Simplification** - Simple +1/-1 system replacing complex logic
10. **âœ… Development Experience** - Port 8080 default, improved mode detection
11. **âœ… Blueprint URL Routing** - All templates updated to use blueprint.endpoint format
12. **âœ… Answer Validation Logic** - Fixed form fields and validation direction
13. **âœ… TTS Integration** - Fixed API endpoints and JavaScript integration

### ðŸŸ¡ YELLOW FLAGS - Technical Debt
1. **Large TTS service (14KB)** - Consider splitting into smaller components
2. **Dual dependency management** - Poetry (dev) + requirements.txt (prod)
3. **Configuration complexity** - Multiple config files with different purposes

### ðŸŸ¢ GREEN FLAGS - Good Practices
1. **âœ… Blueprint Architecture** - Clean feature-based route organization
2. **âœ… Type Safety** - Comprehensive type hints and Pydantic models
3. **âœ… Modular Structure** - Single responsibility per module
4. **âœ… Dual-Store Architecture** - Separation of content vs application data
5. **âœ… Code Quality Automation** - Pre-commit hooks ensure consistency
6. **Configuration management** with Dynaconf
7. **PWA support** with service worker and manifest
8. **Multiple deployment options** (Railway, Heroku)
9. **Comprehensive documentation**

## Development Rules

### 1. File Organization Rules âœ… **IMPLEMENTED**
- **âœ… NEVER add code to monolithic files** - Use blueprint pattern
- **âœ… FEATURE-BASED blueprints** implemented:
  - `routes/auth.py` - Authentication routes âœ…
  - `routes/flashcard.py` - Card-related routes âœ…
  - `routes/settings.py` - Settings and spreadsheet management âœ…
  - `routes/api.py` - API endpoints âœ…
  - `routes/admin.py` - Admin functionality âœ…
  - `routes/test.py` - Testing utilities âœ…
- **âœ… BLUEPRINT registration** - Centralized in `routes/__init__.py`
- **KEEP services focused** - One responsibility per service file

### 2. Code Quality Rules âœ… **IMPLEMENTED**
- **âœ… TYPE HINTS required** - Added throughout all blueprints
- **âœ… PYDANTIC models** for all data validation
- **âœ… ERROR HANDLING** - Comprehensive try/catch blocks
- **âœ… PRE-COMMIT HOOKS** - Automated code quality enforcement:
  - **Ruff**: Fast Python linting and formatting
  - **File checks**: Trailing whitespace, JSON/YAML/TOML validation
  - **Security**: Bandit security scanning, private key detection
  - **No MyPy**: Removed due to excessive strictness for existing codebase
- **NO direct database calls** in routes - use service layer
- **LOGGING** required for all external API calls

### 3. Configuration Rules
- **NEVER hardcode credentials** - use settings.toml/.secrets.toml
- **ENVIRONMENT variables** take precedence over file config
- **VALIDATE configuration** on app startup
- **DOCUMENT all config options** in settings.toml comments

### 4. Data Persistence Rules âœ… **IMPLEMENTED**
- **âœ… DUAL-STORE ARCHITECTURE** - Deliberate separation of concerns:
  - **Google Sheets**: Content management (cards, vocabulary, learning material)
    - Easy for non-technical users to edit and manage content
    - Natural format for language learning data (rows = cards)
    - Version control through Google's revision history
  - **SQLite**: Application data (users, sessions, authentication state)
    - Proper relational data with foreign keys and constraints
    - ACID transactions for user management
    - Fast queries for session and authentication data
- **âœ… NEVER raw SQL** - using SQLAlchemy ORM correctly for application data
- **USE Google Sheets API** for content data with proper error handling
- **CONNECTION pooling** for production

### 5. Frontend Rules
- **PROGRESSIVE enhancement** - work without JS
- **RESPONSIVE design** - mobile-first approach
- **ACCESSIBILITY** - proper ARIA labels and semantic HTML
- **PERFORMANCE** - minimize bundle sizes, lazy loading

### 6. Testing Rules
- **UNIT tests** for all business logic
- **INTEGRATION tests** for API endpoints
- **MOCK external services** (Google Sheets, TTS)
- **TEST configuration** in separate environment

### 7. Security Rules
- **âœ… VALIDATE all inputs** - Pydantic validation in place
- **âœ… SECURITY SCANNING** - Bandit integration via pre-commit
- **SANITIZE outputs** to prevent XSS
- **SECURE sessions** - HTTPOnly, Secure, SameSite
- **RATE LIMITING** on API endpoints
- **AUDIT logs** for sensitive operations

### 8. Performance Rules
- **CACHE TTS audio** (already implemented)
- **LAZY LOAD** vocabulary data
- **DATABASE indexes** on frequently queried fields
- **COMPRESS static assets**
- **CDN** for static files in production

### 9. Deployment Rules
- **DOCKER** containerization preferred
- **ENVIRONMENT parity** - dev should match prod
- **HEALTH CHECKS** for deployment platforms
- **GRACEFUL shutdowns** for data integrity
- **BACKUP strategies** for user data

### 10. Session Management Rules ðŸ†• **IN PROGRESS**

#### Session Architecture Analysis
**Current State (Chaotic):**
- **18 different session keys** scattered across 6 files
- **Inconsistent patterns**: `session['key']` vs `session.get('key', default)`
- **Large data storage**: Full card data (~5KB) stored in sessions
- **No centralized management**: Session operations spread throughout codebase

**Session Storage Confirmation:**
- âœ… **Using filesystem sessions** (not client-side cookies)
- âœ… **Current capacity**: ~500MB per session (confirmed via `flask_session/` directory)
- âœ… **Flask-Session properly configured** in `src/__init__.py`
- âœ… **No 4KB cookie limit issues** (filesystem storage handles large data)

#### SessionManager Design Decisions

**1. Architecture: Static Methods**
```python
# Pattern: Static methods (no instance needed)
sm.get(sk.AUTH_STATE)
sm.set(sk.AUTH_STATE, value)
sm.remove(sk.AUTH_STATE)

# NOT instance methods (rejected)
# sm = SessionManager()
# sm.get(sk.AUTH_STATE)
```

**2. Key Organization: Flat Enum with Prefix Namespacing**
```python
class SessionKeys(Enum):
    # Auth namespace
    AUTH_STATE = 'auth.state'
    AUTH_REDIRECT_URI = 'auth.redirect_uri'
    AUTH_CREDENTIALS = 'auth.credentials'

    # User namespace
    USER_ID = 'user.id'
    USER_GOOGLE_ID = 'user.google_id'

    # Learning namespace
    LEARNING_CARDS = 'learning.cards'
    LEARNING_CURRENT_INDEX = 'learning.current_index'
    LEARNING_ANSWERS = 'learning.answers'
    LEARNING_INCORRECT_CARDS = 'learning.incorrect_cards'
    LEARNING_REVIEWING = 'learning.reviewing'
    LEARNING_ACTIVE_TAB = 'learning.active_tab'
    LEARNING_ORIGINAL_COUNT = 'learning.original_count'
    LEARNING_SHEET_GID = 'learning.sheet_gid'
    LEARNING_LAST_LEVEL_CHANGE = 'learning.last_level_change'
```

**3. Default Values: In Get Method**
```python
# Pattern: Defaults passed to get method
sm.get(sk.LEARNING_CURRENT_INDEX, 0)
sm.get(sk.LEARNING_REVIEWING, False)
sm.get(sk.LEARNING_ANSWERS, [])

# NOT in enum definition (rejected)
```

**4. Type Safety: Simple Get/Set (MVP)**
```python
# Pattern: Simple Any types for MVP
def get(key: SessionKeys, default: Any = None) -> Any
def set(key: SessionKeys, value: Any) -> None

# NOT typed methods initially (future enhancement)
```

**5. Convenience Methods: Pure Get/Set Initially**
```python
# Pattern: Start with core operations only
SessionManager.get(key, default)
SessionManager.set(key, value)
SessionManager.remove(key)

# NOT lifecycle methods initially (future enhancement)
# start_learning_session(), clear_auth_session(), etc.
```

#### Implementation Plan

**File Structure:**
```python
# src/session_manager.py (NEW FILE)
from enum import Enum
from flask import session
from typing import Any

class SessionKeys(Enum):
    # All 18+ session keys with prefix namespacing

class SessionManager:
    @staticmethod
    def get(key: SessionKeys, default: Any = None) -> Any:
        """Get session value with optional default."""
        return session.get(key.value, default)

    @staticmethod
    def set(key: SessionKeys, value: Any) -> None:
        """Set session value."""
        session[key.value] = value

    @staticmethod
    def remove(key: SessionKeys) -> None:
        """Remove session key."""
        session.pop(key.value, None)
```

**Import Pattern:**
```python
# Standard import pattern for all files
from src.session_manager import SessionManager as sm, SessionKeys as sk

# Usage pattern
sm.get(sk.USER_ID)
sm.set(sk.AUTH_STATE, state)
```

#### Gradual Migration Strategy

**Phase 1: Authentication Module (`routes/auth.py`) - LOW RISK**
- **3 session keys** to migrate:
  - `session['state']` â†’ `SessionKeys.AUTH_STATE`
  - `session['redirect_uri']` â†’ `SessionKeys.AUTH_REDIRECT_URI`
  - `session['credentials']` â†’ `SessionKeys.AUTH_CREDENTIALS`
- **Why first**: Smallest impact, isolated functionality, clear boundaries

**Phase 2: User Management (`user_manager.py`) - LOW RISK**
- **2 session keys** to migrate:
  - `session['user_id']` â†’ `SessionKeys.USER_ID`
  - `session['google_user_id']` â†’ `SessionKeys.USER_GOOGLE_ID`
- **Why second**: Small scope, well-defined interface

**Phase 3: Core Learning (`routes/flashcard.py`) - HIGH RISK**
- **13+ session keys** to migrate:
  - All `learning.*` namespace keys
  - Most complex logic with session dependencies
- **Why last**: Highest risk, most complex, core functionality

#### Migration Rules

**MUST follow patterns:**
```python
# âœ… Replace direct session access
# OLD: session['user_id'] = user.id
# NEW: sm.set(sk.USER_ID, user.id)

# âœ… Replace session.get() calls
# OLD: user_id = session.get('user_id')
# NEW: user_id = sm.get(sk.USER_ID)

# âœ… Replace session.pop() calls
# OLD: session.pop('auth_state', None)
# NEW: sm.remove(sk.AUTH_STATE)
```

**MUST NOT patterns:**
```python
# âŒ Do not use direct session access after migration
# session['user_id'] = value  # FORBIDDEN

# âŒ Do not mix old and new patterns in same file
# Migrate entire file in one go

# âŒ Do not create new session keys without adding to enum
# All new keys must be in SessionKeys enum
```

#### Testing Strategy

**Per-Phase Validation:**
1. **Functional Testing**: All existing functionality works unchanged
2. **Session Inspection**: Verify session keys use new prefixed format
3. **Error Testing**: Ensure defensive patterns handle missing keys
4. **Rollback Plan**: Each phase can be reverted independently

**Pre-Migration Checklist:**
- [ ] SessionManager class created and tested
- [ ] All session keys mapped to enum values
- [ ] Import pattern verified in test file
- [ ] Backup of original file created

**Post-Migration Validation:**
- [ ] All tests pass
- [ ] Manual testing of affected functionality
- [ ] Session data inspection shows proper key format
- [ ] No direct `session[]` access remaining in migrated files

#### Success Metrics

**Immediate Goals:**
- âœ… **Centralized session access** through SessionManager
- âœ… **Consistent patterns** across all files
- âœ… **Type-safe session keys** via enum
- âœ… **Refactoring-safe** session operations

**Future Enhancements (Post-Migration):**
- Add typed convenience methods for common operations
- Implement session lifecycle management
- Add session validation and cleanup
- Consider session data optimization patterns

### 11. Refactoring Priorities

#### âœ… COMPLETED
1. **âœ… Split routes.py** - Successfully broken into 6 blueprints (1,090 â†’ 6 focused files)
2. **âœ… Blueprint architecture** - Clean separation by feature
3. **âœ… Type safety** - Added comprehensive type hints
4. **âœ… Error handling** - Improved exception handling
5. **âœ… Data persistence strategy** - Dual-store architecture decision made
6. **âœ… Pre-commit setup** - Automated code quality with ruff, security scanning
7. **âœ… TTS caching implementation** - GCS-based caching with spreadsheet organization
8. **âœ… Comprehensive logging** - Structured logging across all modules
9. **âœ… Level progression simplification** - Replaced complex logic with simple +1/-1
10. **âœ… Development experience** - Port 8080 default, improved development detection
11. **âœ… Blueprint URL routing fixes** - All templates use blueprint.endpoint format
12. **âœ… Answer validation fixes** - Corrected form fields and validation logic

#### High Priority (Do Next)
1. **Create comprehensive service layer** for business logic
2. **Add comprehensive testing** - Unit and integration tests for all blueprints
3. **Add API rate limiting** - Implement proper request throttling

#### Medium Priority
1. **Optimize database queries**
2. **Resolve dual dependency management**

#### Low Priority
1. **Add Docker support**
2. **Implement caching layer**
3. **Add monitoring/metrics**
4. **Performance optimizations**

## Pre-commit Setup âœ… **COMPLETED**

### Configuration
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    hooks:
      - id: ruff          # Fast Python linting with --fix
      - id: ruff-format   # Code formatting

  - repo: https://github.com/pre-commit/pre-commit-hooks
    hooks:
      - id: trailing-whitespace, end-of-file-fixer, mixed-line-ending
      - id: check-json, check-yaml, check-toml
      - id: check-ast, check-builtin-literals, debug-statements
      - id: detect-private-key

  - repo: https://github.com/PyCQA/bandit
    hooks:
      - id: bandit        # Security vulnerability scanning

  - repo: local
    hooks:
      - id: poetry-export  # Custom hook: sync pyproject.toml â†’ requirements.txt
```

### Ruff Configuration (in pyproject.toml)
```toml
[tool.ruff]
target-version = "py311"
line-length = 100

[tool.ruff.lint]
select = ["E", "W", "F", "I", "B", "C4", "UP", "SIM", "PTH", "RUF"]
ignore = ["E501", "PTH110", "PTH100", "PTH103", "PTH123", ...]
```

### Custom Hooks
- **Poetry Export**: Automatically syncs `pyproject.toml` dependencies to `requirements.txt`
  - Ensures Railway deployment always has latest dependencies
  - Runs only when `pyproject.toml` is modified
  - Uses `poetry export --without-hashes` for clean output

### Usage
```bash
# Install hooks (one-time setup)
pre-commit install

# Run on all files
pre-commit run --all-files

# Automatic runs on git commit
git commit -m "message"  # hooks run automatically

# Test specific hook
pre-commit run poetry-export --all-files
```

### Success Metrics
- **All checks passing**: âœ… 14/14 hooks pass successfully
- **Zero security vulnerabilities**: Fixed MD5 hash usage with `usedforsecurity=False`
- **Clean code formatting**: Consistent style across entire codebase
- **Import organization**: Proper import ordering and structure
- **Dependency sync**: requirements.txt automatically updated from pyproject.toml

## Blueprint Patterns âœ… **IMPLEMENTED**

### Blueprint Structure
```python
from flask import Blueprint, render_template, request, redirect, url_for
from typing import Dict, Any, Optional

# Create blueprint with descriptive name
feature_bp = Blueprint('feature', __name__, url_prefix='/feature')

@feature_bp.route('/endpoint')
def endpoint_function() -> ReturnType:
    """Clear docstring describing the endpoint."""
    # Implementation with proper error handling
    pass
```

### Blueprint Registration
```python
# In routes/__init__.py
from flask import Flask
from .auth import auth_bp
from .flashcard import flashcard_bp
# ... other imports

def register_blueprints(app: Flask) -> None:
    """Register all blueprints with the Flask app."""
    app.register_blueprint(auth_bp)
    app.register_blueprint(flashcard_bp)
    # ... register all blueprints
```

### Cross-Blueprint URL Generation
```python
# Use blueprint.endpoint format for url_for
return redirect(url_for('flashcard.index'))
return redirect(url_for('auth.auth'))
```

## Route Organization by Feature âœ… **IMPLEMENTED**

### Authentication Routes (`auth.py`) - 155 lines
- `/auth` - Initiate OAuth flow
- `/oauth2callback` - OAuth callback handler
- `/clear` - Clear credentials

### Core Flashcard Routes (`
